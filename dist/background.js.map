{"version":3,"file":"background.js","mappings":"mBAAA,IAAIA,EAAuB,KACvBC,GAAc,EACdC,EAAgC,KAChCC,EAA4E,GAKhF,SAASC,EAAYC,GACnBC,QAAQC,IACN,IAAIF,WAAiBF,EAAaK,OAClC,iBAAkBP,EAClB,QAASD,EAAKA,EAAGS,WAAa,OAC9B,oBAAqBP,EAEzB,CAEAQ,eAAeC,IAEb,GAAIX,EAAI,CACNA,EAAGY,OAASZ,EAAGa,QAAUb,EAAGc,QAAUd,EAAGe,UAAY,KACrD,IAAMf,EAAGgB,OAAS,CAAE,MAAOC,GAAK,CAChCjB,EAAK,IACP,CAEA,MAGMkB,EAAQ,0BAHYC,OAAOC,QAAQC,KAAKC,IAAI,aACrBC,UAAY,CAAC,GACpBC,MAAQ,OAE9BlB,QAAQC,IAAI,mBAAoBW,GAEhC,IACElB,EAAK,IAAIyB,UAAUP,GAEnBlB,EAAGY,OAAS,KACVN,QAAQC,IAAI,gBACZN,GAAc,EACdyB,GAA0B,GAoDhC,WAEE,IADAtB,EAAY,QACLD,EAAaK,OAAS,GAAKP,GAAeD,GAAMA,EAAGS,aAAegB,UAAUE,MAAM,CACvF,MAAM,QAAEC,EAAO,aAAEC,GAAiB1B,EAAa2B,QAC/C,IACE9B,EAAG+B,KAAKC,KAAKC,UAAU,CACrBC,KAAM,WACNC,QAASP,EAAQO,QACjBC,SAAUR,EAAQQ,SAClBC,UAAWC,KAAKC,SAElBV,EAAa,CAAEW,SAAS,GAC1B,CAAE,MAAOvB,GAEPY,EAAa,CAAEW,SAAS,EAAOC,MADL,iBAANxB,GAAkBA,GAAK,YAAaA,EAAMA,EAAUW,QAAUc,OAAOzB,IAE3F,CACF,CACF,CApEM0B,GACIzC,IACF0C,aAAa1C,GACbA,EAAiB,MAEnBE,EAAY,cAGdJ,EAAGa,QAAU,KAGX,GAFAP,QAAQC,IAAI,mBACZN,GAAc,EACVD,EAAI,IAAMA,EAAGgB,OAAS,CAAE,MAAQ,CACpChB,EAAK,KACL0B,GAA0B,GAC1BmB,IAEAC,EAAqB,SACrB1C,EAAY,eAGdJ,EAAGc,QAAW2B,IACZnC,QAAQmC,MAAM,gBAAiBA,GAC/BxC,GAAc,GAGhBD,EAAGe,UAAagC,IACdzC,QAAQC,IAAI,oBAAqBwC,EAAMC,MACvC,IACE,MAAMpB,EAAUI,KAAKiB,MAAMF,EAAMC,KAAKE,YACjB,gBAAjBtB,EAAQM,OACV5B,QAAQC,IAAI,WAAYqB,EAAQuB,UAChChC,OAAOC,QAAQgC,MAAMC,IAAI,CACvBC,cAAe,CACbH,SAAUvB,EAAQuB,SAClBI,YAAa3B,EAAQ2B,YACrBlB,UAAWC,KAAKC,SAIxB,CAAE,MAAOtB,GACPX,QAAQmC,MAAM,UAAWxB,EAC3B,EAGJ,CAAE,MAAOwB,GACPnC,QAAQmC,MAAM,kBAAmBA,GACjCxC,GAAc,EACd4C,GACF,CACF,CAmCA,SAASC,EAAqBU,EAAS,QACjCrD,EAAaK,OAAS,IACxBL,EAAasD,QAAQC,IACnB,IACEA,EAAK7B,cAAgB6B,EAAK7B,aAAa,CAAEW,SAAS,EAAOC,MAAOe,GAClE,CAAE,MAAQ,IAEZrD,EAAe,GACfG,QAAQqD,KAAK,oBAAoBH,KAErC,CAEA,SAAS9B,EAA0BkC,GACjCzC,OAAO0C,KAAKC,MAAM,CAAC,EAAID,IACrBA,EAAKJ,QAASM,IACRA,EAAIC,IACN7C,OAAO0C,KAAKI,YAAYF,EAAIC,GAAI,CAC9B9B,KAAM,mBACNgC,OAAQN,EAAY,YAAc,iBACjCO,MAAM,WAIjB,CAEA,SAAStB,IACH3C,IACJA,EAAiBkE,WAAW,KAC1B9D,QAAQC,IAAI,aACZI,KACC,KACL,CAEA,SAAS0D,EAAoBzC,EAAcC,GACzC,IAAK5B,IAAgBD,GAAMA,EAAGS,aAAegB,UAAUE,KAGrD,OAnDJ,SAAsBC,EAAcC,GAMlC,GAJA1B,EAAeA,EAAamE,OAC1BZ,GAAQpB,KAAKC,MAAQmB,EAAKa,GAzGH,MA2GzBjE,QAAQC,IAAI,uBAAwB,UAAWJ,EAAaK,QACxDL,EAAaK,QA7GS,GA6GsB,CAE9C,MAAMgE,EAAUrE,EAAa2B,QAC7B0C,GAAS3C,cAAgB2C,EAAQ3C,aAAa,CAAEW,SAAS,EAAOC,MAAO,mBACzE,CACAtC,EAAasE,KAAK,CAAE7C,UAASC,eAAc0C,GAAIjC,KAAKC,OACtD,CAqCImC,CAAa9C,EAASC,QACtBzB,EAAY,8BAId,IACE,MAAMuE,EAAiB,CACrBtC,UAAWC,KAAKC,OAGG,cAAjBX,EAAQM,MACV5B,QAAQC,IAAI,uDAAwDqB,EAAQgD,QAAU5C,KAAKC,UAAUL,EAAQgD,SAASpE,OAAS,aAC/HmE,EAAUzC,KAAO,YACjByC,EAAUC,QAAUhD,EAAQgD,SACF,UAAjBhD,EAAQM,MACjByC,EAAUzC,KAAO,YACjByC,EAAUxC,QAAUP,EAAQO,QAC5BwC,EAAUvC,SAAWR,EAAQQ,SAC7BuC,EAAUE,SAAWjD,EAAQiD,UAAY,KAGzCF,EAAUzC,KAAO,WACjByC,EAAUxC,QAAUP,EAAQO,QAC5BwC,EAAUvC,SAAWR,EAAQQ,SAC7BuC,EAAUE,SAAWjD,EAAQiD,UAAY,IAG3C7E,EAAG+B,KAAKC,KAAKC,UAAU0C,IACvBvE,EAAY,6BACZyB,EAAa,CAAEW,SAAS,GAC1B,CAAE,MAAOC,GAEPZ,EAAa,CAAEW,SAAS,EAAOC,MADD,iBAAVA,GAAsBA,GAAS,YAAaA,EAAUA,EAAcb,QAAUc,OAAOD,IAE3G,CACF,CA8BAtB,OAAO2D,QAAQC,UAAUC,YAAY,CAACpD,EAASqD,EAAQpD,IAC9B,iBAAnBD,EAAQsD,QACV9E,EAAY,UACZiE,EAAoBzC,EAASC,IACtB,GAGc,sBAAnBD,EAAQsD,QAlCdxE,eAAuCmB,GACrC,IACE,MAAOkC,SAAa5C,OAAO0C,KAAKC,MAAM,CAAEqB,QAAQ,EAAMC,eAAe,IACrE,IAAKrB,IAAQA,EAAIC,GAEf,YADAnC,EAAa,CAAEW,SAAS,EAAOC,MAAO,aAIxC,MAAM4C,QAAgBlE,OAAO0C,KAAKyB,kBAAkBvB,EAAIwB,SAAU,CAAEC,OAAQ,QAG5EnB,EAAoB,CAClBa,OAAQ,eACRhD,KAAM,aACNmD,QAASA,EACTjD,SAAU,cAAcE,KAAKC,aAC3BkD,IAEF5D,EAAa,IAAK4D,EAAYJ,QAASA,KAG3C,CAAE,MAAO5C,GACPnC,QAAQmC,MAAM,QAASA,GACvBZ,EAAa,CAAEW,SAAS,EAAOC,MAAO,SAAWC,OAAOD,IAC1D,CACF,CAUIiD,CAAwB7D,IACjB,GAGc,wBAAnBD,EAAQsD,QAIW,SAAnBtD,EAAQsD,QAHVrD,EAAa,CAAE+B,UAAW3D,KACnB,QAET,GAMFU,IAEAQ,OAAOC,QAAQuE,UAAUX,YAAaY,IACpC,GAAIA,EAAQrE,SAAU,CACpB,MAAMsE,EAAcD,EAAQrE,SAASuE,UAAY,CAAC,EAC5CC,EAAcH,EAAQrE,SAASyE,UAAY,CAAC,EAElD,GAAIH,EAAYrE,OAASuE,EAAYvE,KAAM,CAIzC,GAHAlB,QAAQC,IAAI,mBAEZuC,EAAqB,UACjB9C,EAAM,IAAMA,EAAGgB,OAAS,CAAE,MAAQ,CACtCoD,WAAW,IAAMzD,IAAoB,IACvC,CACF,IAIFsF,YAAY,KACV,GAAI9F,EAAaK,OAAS,EAAG,CAC3B,MAAM+B,EAAMD,KAAKC,MACjB,IAAI2D,EAAU,EACd/F,EAAeA,EAAamE,OAAOZ,KAC7BnB,EAAMmB,EAAKa,GApQM,OAqQnBb,EAAK7B,cAAgB6B,EAAK7B,aAAa,CAAEW,SAAS,EAAOC,MAAO,gBAChEyD,IACO,KAIPA,EAAU,GAAG5F,QAAQqD,KAAK,mCAAmCuC,KACnE,GACC,I","sources":["webpack://ai-to-vscode-bridge/./src/background.ts"],"sourcesContent":["let ws: WebSocket | null = null;\r\nlet isConnected = false;\r\nlet reconnectTimer: number | null = null;\r\nlet messageQueue: Array<{ message: any; sendResponse: Function; ts: number }> = [];\r\n\r\nconst MESSAGE_QUEUE_LIMIT = 50;\r\nconst MESSAGE_TIMEOUT_MS = 15000;\r\n\r\nfunction debugStatus(prefix: string) {\r\n  console.log(\r\n    `[${prefix}] 队列长度:`, messageQueue.length,\r\n    ', isConnected:', isConnected,\r\n    ', ws:', ws ? ws.readyState : 'null',\r\n    ', reconnectTimer:', reconnectTimer\r\n  );\r\n}\r\n\r\nasync function connectWebSocket() {\r\n  // 清理已存在的ws事件，彻底断开（防止多实例）\r\n  if (ws) {\r\n    ws.onopen = ws.onclose = ws.onerror = ws.onmessage = null;\r\n    try { ws.close(); } catch (e) { }\r\n    ws = null;\r\n  }\r\n\r\n  const storageData = await chrome.storage.sync.get('settings');\r\n  const settings = storageData.settings || {};\r\n  const port = settings.port || 8765;\r\n  const wsUrl = `ws://localhost:${port}`;\r\n  console.log('尝试连接到 WebSocket:', wsUrl);\r\n\r\n  try {\r\n    ws = new WebSocket(wsUrl);\r\n\r\n    ws.onopen = () => {\r\n      console.log('已连接到 VS Code');\r\n      isConnected = true;\r\n      broadcastConnectionStatus(true);\r\n      processMessageQueue();\r\n      if (reconnectTimer) {\r\n        clearTimeout(reconnectTimer);\r\n        reconnectTimer = null;\r\n      }\r\n      debugStatus('ws.onopen');\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      console.log('WebSocket 连接已关闭');\r\n      isConnected = false;\r\n      if (ws) try { ws.close(); } catch { }\r\n      ws = null;\r\n      broadcastConnectionStatus(false);\r\n      scheduleReconnect();\r\n      // 每次断开清理全部pending响应\r\n      failAllQueueAndClear('连接已断开');\r\n      debugStatus('ws.onclose');\r\n    };\r\n\r\n    ws.onerror = (error) => {\r\n      console.error('WebSocket 错误:', error);\r\n      isConnected = false;\r\n    };\r\n\r\n    ws.onmessage = (event) => {\r\n      console.log('收到来自 VS Code 的消息:', event.data);\r\n      try {\r\n        const message = JSON.parse(event.data.toString());\r\n        if (message.type === 'projectInfo') {\r\n          console.log('活跃项目已更新:', message.rootPath);\r\n          chrome.storage.local.set({\r\n            activeProject: {\r\n              rootPath: message.rootPath,\r\n              projectName: message.projectName,\r\n              timestamp: Date.now()\r\n            }\r\n          });\r\n        }\r\n      } catch (e) {\r\n        console.error('解析消息失败:', e);\r\n      }\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('WebSocket 连接失败:', error);\r\n    isConnected = false;\r\n    scheduleReconnect();\r\n  }\r\n}\r\n\r\nfunction processMessageQueue() {\r\n  debugStatus('处理队列');\r\n  while (messageQueue.length > 0 && isConnected && ws && ws.readyState === WebSocket.OPEN) {\r\n    const { message, sendResponse } = messageQueue.shift()!;\r\n    try {\r\n      ws.send(JSON.stringify({\r\n        type: 'saveFile',\r\n        content: message.content,\r\n        filename: message.filename,\r\n        timestamp: Date.now()\r\n      }));\r\n      sendResponse({ success: true });\r\n    } catch (e) {\r\n      const msg = (typeof e === 'object' && e && 'message' in e) ? (e as any).message : String(e);\r\n      sendResponse({ success: false, error: msg });\r\n    }\r\n  }\r\n}\r\n\r\nfunction queueMessage(message: any, sendResponse: Function) {\r\n  // 排队前检测长度并清理过时callback\r\n  messageQueue = messageQueue.filter(\r\n    item => Date.now() - item.ts < MESSAGE_TIMEOUT_MS\r\n  );\r\n  console.log('WebSocket 未连接，消息加入队列', '当前队列长度:', messageQueue.length);\r\n  if (messageQueue.length >= MESSAGE_QUEUE_LIMIT) {\r\n    // 超出队列上限时（异常），逐个fail\r\n    const removed = messageQueue.shift();\r\n    removed?.sendResponse && removed.sendResponse({ success: false, error: '消息队列已满，已丢弃一条旧请求' });\r\n  }\r\n  messageQueue.push({ message, sendResponse, ts: Date.now() });\r\n}\r\n\r\nfunction failAllQueueAndClear(reason = '未知错误') {\r\n  if (messageQueue.length > 0) {\r\n    messageQueue.forEach(item => {\r\n      try {\r\n        item.sendResponse && item.sendResponse({ success: false, error: reason });\r\n      } catch { }\r\n    });\r\n    messageQueue = [];\r\n    console.warn(`[debug] 队列全部清空，因：${reason}`);\r\n  }\r\n}\r\n\r\nfunction broadcastConnectionStatus(connected: boolean) {\r\n  chrome.tabs.query({}, (tabs) => {\r\n    tabs.forEach((tab) => {\r\n      if (tab.id) {\r\n        chrome.tabs.sendMessage(tab.id, {\r\n          type: 'connectionStatus',\r\n          status: connected ? 'connected' : 'disconnected'\r\n        }).catch(() => { });\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction scheduleReconnect() {\r\n  if (reconnectTimer) return;\r\n  reconnectTimer = setTimeout(() => {\r\n    console.log('尝试重新连接...');\r\n    connectWebSocket();\r\n  }, 3000);\r\n}\r\n\r\nfunction sendMessageToVSCode(message: any, sendResponse: Function) {\r\n  if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {\r\n    queueMessage(message, sendResponse);\r\n    debugStatus('sendMessageToVSCode: queue');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const wsMessage: any = {\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    if (message.type === 'clonePage') {\r\n      console.log('Background received clonePage message. Package size:', message.package ? JSON.stringify(message.package).length : 'undefined');\r\n      wsMessage.type = 'clonePage';\r\n      wsMessage.package = message.package;\r\n    } else if (message.type === 'patch') {\r\n      wsMessage.type = 'patchFile';\r\n      wsMessage.content = message.content;\r\n      wsMessage.filename = message.filename;\r\n      wsMessage.savePath = message.savePath || '';\r\n    } else {\r\n      // Default to saveFile\r\n      wsMessage.type = 'saveFile';\r\n      wsMessage.content = message.content;\r\n      wsMessage.filename = message.filename;\r\n      wsMessage.savePath = message.savePath || '';\r\n    }\r\n\r\n    ws.send(JSON.stringify(wsMessage));\r\n    debugStatus('sendMessageToVSCode: sent');\r\n    sendResponse({ success: true });\r\n  } catch (error) {\r\n    const msg = (typeof error === 'object' && error && 'message' in error) ? (error as any).message : String(error);\r\n    sendResponse({ success: false, error: msg });\r\n  }\r\n}\r\n\r\n\r\nasync function handleCaptureScreenshot(sendResponse: Function) {\r\n  try {\r\n    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\r\n    if (!tab || !tab.id) {\r\n      sendResponse({ success: false, error: '未找到活动标签页' });\r\n      return;\r\n    }\r\n\r\n    const dataUrl = await chrome.tabs.captureVisibleTab(tab.windowId, { format: 'png' });\r\n\r\n    // 发送到 VS Code\r\n    sendMessageToVSCode({\r\n      action: 'sendToVSCode',\r\n      type: 'screenshot',\r\n      dataUrl: dataUrl,\r\n      filename: `screenshot_${Date.now()}.png`\r\n    }, (vsResponse: any) => {\r\n      // 将 dataUrl 返回给 content script，以便其写入剪贴板\r\n      sendResponse({ ...vsResponse, dataUrl: dataUrl });\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('截图失败:', error);\r\n    sendResponse({ success: false, error: '截图失败: ' + String(error) });\r\n  }\r\n}\r\n\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n  if (message.action === 'sendToVSCode') {\r\n    debugStatus('收到发送请求');\r\n    sendMessageToVSCode(message, sendResponse);\r\n    return true; // 一定返回true以便异步call\r\n  }\r\n\r\n  if (message.action === 'captureScreenshot') {\r\n    handleCaptureScreenshot(sendResponse);\r\n    return true;\r\n  }\r\n\r\n  if (message.action === 'getConnectionStatus') {\r\n    sendResponse({ connected: isConnected });\r\n    return true;\r\n  }\r\n  if (message.action === 'ping') {\r\n    sendResponse({ connected: isConnected });\r\n    return true;\r\n  }\r\n});\r\n\r\nconnectWebSocket();\r\n\r\nchrome.storage.onChanged.addListener((changes) => {\r\n  if (changes.settings) {\r\n    const oldSettings = changes.settings.oldValue || {};\r\n    const newSettings = changes.settings.newValue || {};\r\n\r\n    if (oldSettings.port !== newSettings.port) {\r\n      console.log('端口配置已更改，重新连接...');\r\n      // 彻底清理旧队列和ws，从头开始\r\n      failAllQueueAndClear('端口变更清理');\r\n      if (ws) { try { ws.close(); } catch { } }\r\n      setTimeout(() => connectWebSocket(), 500);\r\n    }\r\n  }\r\n});\r\n\r\n// 定时清理已积压超时请求的callback，防止永远pending\r\nsetInterval(() => {\r\n  if (messageQueue.length > 0) {\r\n    const now = Date.now();\r\n    let cleared = 0;\r\n    messageQueue = messageQueue.filter(item => {\r\n      if (now - item.ts > MESSAGE_TIMEOUT_MS) {\r\n        item.sendResponse && item.sendResponse({ success: false, error: '处理超时，后台自动清理' });\r\n        cleared++;\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n    if (cleared > 0) console.warn(`[debug] 定时自动清理超时队列 callback: 清理了${cleared}条`);\r\n  }\r\n}, 10000);\r\n\r\n"],"names":["ws","isConnected","reconnectTimer","messageQueue","debugStatus","prefix","console","log","length","readyState","async","connectWebSocket","onopen","onclose","onerror","onmessage","close","e","wsUrl","chrome","storage","sync","get","settings","port","WebSocket","broadcastConnectionStatus","OPEN","message","sendResponse","shift","send","JSON","stringify","type","content","filename","timestamp","Date","now","success","error","String","processMessageQueue","clearTimeout","scheduleReconnect","failAllQueueAndClear","event","data","parse","toString","rootPath","local","set","activeProject","projectName","reason","forEach","item","warn","connected","tabs","query","tab","id","sendMessage","status","catch","setTimeout","sendMessageToVSCode","filter","ts","removed","push","queueMessage","wsMessage","package","savePath","runtime","onMessage","addListener","sender","action","active","currentWindow","dataUrl","captureVisibleTab","windowId","format","vsResponse","handleCaptureScreenshot","onChanged","changes","oldSettings","oldValue","newSettings","newValue","setInterval","cleared"],"sourceRoot":""}