{"version":3,"file":"background.js","mappings":"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","sources":["webpack://ai-to-vscode-bridge/./src/background.ts"],"sourcesContent":["let ws: WebSocket | null = null;\r\nlet isConnected = false;\r\nlet reconnectTimer: number | null = null;\r\nlet messageQueue: Array<{ message: any; sendResponse: Function; ts: number }> = [];\r\n\r\nconst MESSAGE_QUEUE_LIMIT = 50;\r\nconst MESSAGE_TIMEOUT_MS = 15000;\r\n\r\nfunction debugStatus(prefix: string) {\r\n  console.log(\r\n    `[${prefix}] 队列长度:`, messageQueue.length,\r\n    ', isConnected:', isConnected,\r\n    ', ws:', ws ? ws.readyState : 'null',\r\n    ', reconnectTimer:', reconnectTimer\r\n  );\r\n}\r\n\r\nasync function connectWebSocket() {\r\n  // 清理已存在的ws事件，彻底断开（防止多实例）\r\n  if (ws) {\r\n    ws.onopen = ws.onclose = ws.onerror = ws.onmessage = null;\r\n    try { ws.close(); } catch (e) { }\r\n    ws = null;\r\n  }\r\n\r\n  const settings = await chrome.storage.sync.get({ port: 8765 });\r\n  const port = settings.port || 8765;\r\n  const wsUrl = `ws://localhost:${port}`;\r\n  console.log('尝试连接到 WebSocket:', wsUrl);\r\n\r\n  try {\r\n    ws = new WebSocket(wsUrl);\r\n\r\n    ws.onopen = () => {\r\n      console.log('已连接到 VS Code');\r\n      isConnected = true;\r\n      broadcastConnectionStatus(true);\r\n      processMessageQueue();\r\n      if (reconnectTimer) {\r\n        clearTimeout(reconnectTimer);\r\n        reconnectTimer = null;\r\n      }\r\n      debugStatus('ws.onopen');\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      console.log('WebSocket 连接已关闭');\r\n      isConnected = false;\r\n      if (ws) try { ws.close(); } catch { }\r\n      ws = null;\r\n      broadcastConnectionStatus(false);\r\n      scheduleReconnect();\r\n      // 每次断开清理全部pending响应\r\n      failAllQueueAndClear('连接已断开');\r\n      debugStatus('ws.onclose');\r\n    };\r\n\r\n    ws.onerror = (error) => {\r\n      console.error('WebSocket 错误:', error);\r\n      isConnected = false;\r\n    };\r\n\r\n    ws.onmessage = (event) => {\r\n      console.log('收到来自 VS Code 的消息:', event.data);\r\n      try {\r\n        const message = JSON.parse(event.data.toString());\r\n        if (message.type === 'projectInfo') {\r\n          console.log('活跃项目已更新:', message.rootPath);\r\n          chrome.storage.local.set({\r\n            activeProject: {\r\n              rootPath: message.rootPath,\r\n              projectName: message.projectName,\r\n              timestamp: Date.now()\r\n            }\r\n          });\r\n        }\r\n      } catch (e) {\r\n        console.error('解析消息失败:', e);\r\n      }\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('WebSocket 连接失败:', error);\r\n    isConnected = false;\r\n    scheduleReconnect();\r\n  }\r\n}\r\n\r\nfunction processMessageQueue() {\r\n  debugStatus('处理队列');\r\n  while (messageQueue.length > 0 && isConnected && ws && ws.readyState === WebSocket.OPEN) {\r\n    const { message, sendResponse } = messageQueue.shift()!;\r\n    try {\r\n      ws.send(JSON.stringify({\r\n        type: 'saveFile',\r\n        content: message.content,\r\n        filename: message.filename,\r\n        timestamp: Date.now()\r\n      }));\r\n      sendResponse({ success: true });\r\n    } catch (e) {\r\n      const msg = (typeof e === 'object' && e && 'message' in e) ? (e as any).message : String(e);\r\n      sendResponse({ success: false, error: msg });\r\n    }\r\n  }\r\n}\r\n\r\nfunction queueMessage(message: any, sendResponse: Function) {\r\n  // 排队前检测长度并清理过时callback\r\n  messageQueue = messageQueue.filter(\r\n    item => Date.now() - item.ts < MESSAGE_TIMEOUT_MS\r\n  );\r\n  console.log('WebSocket 未连接，消息加入队列', '当前队列长度:', messageQueue.length);\r\n  if (messageQueue.length >= MESSAGE_QUEUE_LIMIT) {\r\n    // 超出队列上限时（异常），逐个fail\r\n    const removed = messageQueue.shift();\r\n    removed?.sendResponse && removed.sendResponse({ success: false, error: '消息队列已满，已丢弃一条旧请求' });\r\n  }\r\n  messageQueue.push({ message, sendResponse, ts: Date.now() });\r\n}\r\n\r\nfunction failAllQueueAndClear(reason = '未知错误') {\r\n  if (messageQueue.length > 0) {\r\n    messageQueue.forEach(item => {\r\n      try {\r\n        item.sendResponse && item.sendResponse({ success: false, error: reason });\r\n      } catch { }\r\n    });\r\n    messageQueue = [];\r\n    console.warn(`[debug] 队列全部清空，因：${reason}`);\r\n  }\r\n}\r\n\r\nfunction broadcastConnectionStatus(connected: boolean) {\r\n  chrome.tabs.query({}, (tabs) => {\r\n    tabs.forEach((tab) => {\r\n      if (tab.id) {\r\n        chrome.tabs.sendMessage(tab.id, {\r\n          type: 'connectionStatus',\r\n          status: connected ? 'connected' : 'disconnected'\r\n        }).catch(() => { });\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction scheduleReconnect() {\r\n  if (reconnectTimer) return;\r\n  reconnectTimer = setTimeout(() => {\r\n    console.log('尝试重新连接...');\r\n    connectWebSocket();\r\n  }, 3000);\r\n}\r\n\r\nfunction sendMessageToVSCode(message: any, sendResponse: Function) {\r\n  if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {\r\n    queueMessage(message, sendResponse);\r\n    debugStatus('sendMessageToVSCode: queue');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    ws.send(JSON.stringify({\r\n      type: message.type === 'patch' ? 'patchFile' : 'saveFile',\r\n      content: message.content,\r\n      filename: message.filename,\r\n      savePath: message.savePath || '',  // 传递路径\r\n      timestamp: Date.now()\r\n    }));\r\n    debugStatus('sendMessageToVSCode: sent');\r\n    sendResponse({ success: true });\r\n  } catch (error) {\r\n    const msg = (typeof error === 'object' && error && 'message' in error) ? (error as any).message : String(error);\r\n    sendResponse({ success: false, error: msg });\r\n  }\r\n}\r\n\r\n\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n  if (message.action === 'sendToVSCode') {\r\n    debugStatus('收到发送请求');\r\n    sendMessageToVSCode(message, sendResponse);\r\n    return true; // 一定返回true以便异步call\r\n  }\r\n\r\n  if (message.action === 'getConnectionStatus') {\r\n    sendResponse({ connected: isConnected });\r\n    return true;\r\n  }\r\n  if (message.action === 'ping') {\r\n    sendResponse({ connected: isConnected });\r\n    return true;\r\n  }\r\n});\r\n\r\nconnectWebSocket();\r\n\r\nchrome.storage.onChanged.addListener((changes) => {\r\n  if (changes.port) {\r\n    console.log('端口配置已更改，重新连接...');\r\n    // 彻底清理旧队列和ws，从头开始\r\n    failAllQueueAndClear('端口变更清理');\r\n    if (ws) { try { ws.close(); } catch { } }\r\n    setTimeout(() => connectWebSocket(), 500);\r\n  }\r\n});\r\n\r\n// 定时清理已积压超时请求的callback，防止永远pending\r\nsetInterval(() => {\r\n  if (messageQueue.length > 0) {\r\n    const now = Date.now();\r\n    let cleared = 0;\r\n    messageQueue = messageQueue.filter(item => {\r\n      if (now - item.ts > MESSAGE_TIMEOUT_MS) {\r\n        item.sendResponse && item.sendResponse({ success: false, error: '处理超时，后台自动清理' });\r\n        cleared++;\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n    if (cleared > 0) console.warn(`[debug] 定时自动清理超时队列 callback: 清理了${cleared}条`);\r\n  }\r\n}, 10000);\r\n\r\n"],"names":["ws","isConnected","reconnectTimer","messageQueue","debugStatus","prefix","console","log","length","readyState","async","connectWebSocket","onopen","onclose","onerror","onmessage","close","e","wsUrl","chrome","storage","sync","get","port","WebSocket","broadcastConnectionStatus","OPEN","message","sendResponse","shift","send","JSON","stringify","type","content","filename","timestamp","Date","now","success","error","String","processMessageQueue","clearTimeout","scheduleReconnect","failAllQueueAndClear","event","data","parse","toString","rootPath","local","set","activeProject","projectName","reason","forEach","item","warn","connected","tabs","query","tab","id","sendMessage","status","catch","setTimeout","runtime","onMessage","addListener","sender","action","filter","ts","removed","push","queueMessage","savePath","sendMessageToVSCode","onChanged","changes","setInterval","cleared"],"sourceRoot":""}