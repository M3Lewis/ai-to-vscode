{"version":3,"file":"background.js","mappings":"mBAAA,IAAIA,EAAuB,KACvBC,GAAc,EACdC,EAAgC,KAChCC,EAA4E,GAKhF,SAASC,EAAYC,GACnBC,QAAQC,IACN,IAAIF,WAAiBF,EAAaK,OAClC,iBAAkBP,EAClB,QAASD,EAAKA,EAAGS,WAAa,OAC9B,oBAAqBP,EAEzB,CAEAQ,eAAeC,IAEb,GAAIX,EAAI,CACNA,EAAGY,OAASZ,EAAGa,QAAUb,EAAGc,QAAUd,EAAGe,UAAY,KACrD,IAAMf,EAAGgB,OAAS,CAAE,MAAOC,GAAI,CAC/BjB,EAAK,IACP,CAEA,MAEMkB,EAAQ,yBAFSC,OAAOC,QAAQC,KAAKC,IAAI,CAAEC,KAAM,QACjCA,MAAQ,OAE9BjB,QAAQC,IAAI,mBAAoBW,GAEhC,IACElB,EAAK,IAAIwB,UAAUN,GAEnBlB,EAAGY,OAAS,KACVN,QAAQC,IAAI,gBACZN,GAAc,EACdwB,GAA0B,GAqChC,WAEE,IADArB,EAAY,QACLD,EAAaK,OAAS,GAAKP,GAAeD,GAAMA,EAAGS,aAAee,UAAUE,MAAM,CACvF,MAAM,QAAEC,EAAO,aAAEC,GAAiBzB,EAAa0B,QAC/C,IACE7B,EAAG8B,KAAKC,KAAKC,UAAU,CACrBC,KAAM,WACNC,QAASP,EAAQO,QACjBC,SAAUR,EAAQQ,SAClBC,UAAWC,KAAKC,SAElBV,EAAa,CAAEW,SAAS,GAC1B,CAAE,MAAOtB,GAEXW,EAAa,CAAEW,SAAS,EAAOC,MADL,iBAANvB,GAAkBA,GAAK,YAAaA,EAAMA,EAAUU,QAAUc,OAAOxB,IAE3F,CACE,CACF,CArDMyB,GACIxC,IACFyC,aAAazC,GACbA,EAAiB,MAEnBE,EAAY,cAGdJ,EAAGa,QAAU,KAGX,GAFAP,QAAQC,IAAI,mBACZN,GAAc,EACVD,EAAI,IAAMA,EAAGgB,OAAS,CAAE,MAAO,CACnChB,EAAK,KACLyB,GAA0B,GAC1BmB,IAEAC,EAAqB,SACrBzC,EAAY,eAGdJ,EAAGc,QAAW0B,IACZlC,QAAQkC,MAAM,gBAAiBA,GAC/BvC,GAAc,GAGhBD,EAAGe,UAAa+B,IACdxC,QAAQC,IAAI,oBAAqBuC,EAAMC,MAG3C,CAAE,MAAOP,GACPlC,QAAQkC,MAAM,kBAAmBA,GACjCvC,GAAc,EACd2C,GACF,CACF,CAmCA,SAASC,EAAqBG,EAAS,QACjC7C,EAAaK,OAAS,IACxBL,EAAa8C,QAAQC,IACnB,IACEA,EAAKtB,cAAgBsB,EAAKtB,aAAa,CAAEW,SAAS,EAAOC,MAAOQ,GAClE,CAAE,MAAO,IAEX7C,EAAe,GACfG,QAAQ6C,KAAK,oBAAoBH,KAErC,CAEA,SAASvB,EAA0B2B,GACjCjC,OAAOkC,KAAKC,MAAM,CAAC,EAAID,IACrBA,EAAKJ,QAASM,IACRA,EAAIC,IACNrC,OAAOkC,KAAKI,YAAYF,EAAIC,GAAI,CAC9BvB,KAAM,mBACNyB,OAAQN,EAAY,YAAc,iBACjCO,MAAM,WAIjB,CAEA,SAASf,IACH1C,IACJA,EAAiB0D,WAAW,KAC1BtD,QAAQC,IAAI,aACZI,KACC,KACL,CA0BAQ,OAAO0C,QAAQC,UAAUC,YAAY,CAACpC,EAASqC,EAAQpC,IAC9B,iBAAnBD,EAAQsC,QACV7D,EAAY,UA1BhB,SAA6BuB,EAAcC,GACzC,IAAK3B,IAAgBD,GAAMA,EAAGS,aAAee,UAAUE,KAGrD,OAnDJ,SAAsBC,EAAcC,GAMlC,GAJAzB,EAAeA,EAAa+D,OAC1BhB,GAAQb,KAAKC,MAAQY,EAAKiB,GAzFH,MA2FzB7D,QAAQC,IAAI,uBAAwB,UAAWJ,EAAaK,QACxDL,EAAaK,QA7FS,GA6FsB,CAE9C,MAAM4D,EAAUjE,EAAa0B,QAC7BuC,GAASxC,cAAgBwC,EAAQxC,aAAa,CAAEW,SAAS,EAAOC,MAAO,mBACzE,CACArC,EAAakE,KAAK,CAAE1C,UAASC,eAAcuC,GAAI9B,KAAKC,OACtD,CAqCIgC,CAAa3C,EAASC,QACtBxB,EAAY,8BAId,IACEJ,EAAG8B,KAAKC,KAAKC,UAAU,CACrBC,KAAM,WACNC,QAASP,EAAQO,QACjBC,SAAUR,EAAQQ,SAClBoC,SAAU5C,EAAQ4C,UAAY,GAC9BnC,UAAWC,KAAKC,SAElBlC,EAAY,6BACZwB,EAAa,CAAEW,SAAS,GAC1B,CAAE,MAAOC,GAEPZ,EAAa,CAAEW,SAAS,EAAOC,MADD,iBAAVA,GAAsBA,GAAS,YAAaA,EAAUA,EAAcb,QAAUc,OAAOD,IAE3G,CACF,CAMIgC,CAAoB7C,EAASC,IACtB,GAGc,wBAAnBD,EAAQsC,QAIW,SAAnBtC,EAAQsC,QAHVrC,EAAa,CAAEwB,UAAWnD,KACnB,QAET,GAMFU,IAEAQ,OAAOC,QAAQqD,UAAUV,YAAaW,IACpC,GAAIA,EAAQnD,KAAM,CAIhB,GAHAjB,QAAQC,IAAI,mBAEZsC,EAAqB,UACjB7C,EAAM,IAAMA,EAAGgB,OAAS,CAAE,MAAO,CACrC4C,WAAW,IAAMjD,IAAoB,IACvC,IAIFgE,YAAY,KACV,GAAIxE,EAAaK,OAAS,EAAG,CAC3B,MAAM8B,EAAMD,KAAKC,MACjB,IAAIsC,EAAU,EACdzE,EAAeA,EAAa+D,OAAOhB,KAC7BZ,EAAMY,EAAKiB,GAhMM,OAiMnBjB,EAAKtB,cAAgBsB,EAAKtB,aAAa,CAAEW,SAAS,EAAOC,MAAO,gBAChEoC,IACO,KAIPA,EAAU,GAAGtE,QAAQ6C,KAAK,mCAAmCyB,KACnE,GACC,I","sources":["webpack://ai-to-vscode-bridge/./src/background.ts"],"sourcesContent":["let ws: WebSocket | null = null;\r\nlet isConnected = false;\r\nlet reconnectTimer: number | null = null;\r\nlet messageQueue: Array<{ message: any; sendResponse: Function; ts: number }> = [];\r\n\r\nconst MESSAGE_QUEUE_LIMIT = 50;\r\nconst MESSAGE_TIMEOUT_MS = 15000;\r\n\r\nfunction debugStatus(prefix: string) {\r\n  console.log(\r\n    `[${prefix}] 队列长度:`, messageQueue.length,\r\n    ', isConnected:', isConnected,\r\n    ', ws:', ws ? ws.readyState : 'null',\r\n    ', reconnectTimer:', reconnectTimer\r\n  );\r\n}\r\n\r\nasync function connectWebSocket() {\r\n  // 清理已存在的ws事件，彻底断开（防止多实例）\r\n  if (ws) {\r\n    ws.onopen = ws.onclose = ws.onerror = ws.onmessage = null;\r\n    try { ws.close(); } catch (e) {}\r\n    ws = null;\r\n  }\r\n\r\n  const settings = await chrome.storage.sync.get({ port: 8765 });\r\n  const port = settings.port || 8765;\r\n  const wsUrl = `ws://localhost:${port}`;\r\n  console.log('尝试连接到 WebSocket:', wsUrl);\r\n\r\n  try {\r\n    ws = new WebSocket(wsUrl);\r\n\r\n    ws.onopen = () => {\r\n      console.log('已连接到 VS Code');\r\n      isConnected = true;\r\n      broadcastConnectionStatus(true);\r\n      processMessageQueue();\r\n      if (reconnectTimer) {\r\n        clearTimeout(reconnectTimer);\r\n        reconnectTimer = null;\r\n      }\r\n      debugStatus('ws.onopen');\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      console.log('WebSocket 连接已关闭');\r\n      isConnected = false;\r\n      if (ws) try { ws.close(); } catch {}\r\n      ws = null;\r\n      broadcastConnectionStatus(false);\r\n      scheduleReconnect();\r\n      // 每次断开清理全部pending响应\r\n      failAllQueueAndClear('连接已断开');\r\n      debugStatus('ws.onclose');\r\n    };\r\n\r\n    ws.onerror = (error) => {\r\n      console.error('WebSocket 错误:', error);\r\n      isConnected = false;\r\n    };\r\n\r\n    ws.onmessage = (event) => {\r\n      console.log('收到来自 VS Code 的消息:', event.data);\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('WebSocket 连接失败:', error);\r\n    isConnected = false;\r\n    scheduleReconnect();\r\n  }\r\n}\r\n\r\nfunction processMessageQueue() {\r\n  debugStatus('处理队列');\r\n  while (messageQueue.length > 0 && isConnected && ws && ws.readyState === WebSocket.OPEN) {\r\n    const { message, sendResponse } = messageQueue.shift()!;\r\n    try {\r\n      ws.send(JSON.stringify({\r\n        type: 'saveFile',\r\n        content: message.content,\r\n        filename: message.filename,\r\n        timestamp: Date.now()\r\n      }));\r\n      sendResponse({ success: true });\r\n    } catch (e) {\r\n  const msg = (typeof e === 'object' && e && 'message' in e) ? (e as any).message : String(e);\r\n  sendResponse({ success: false, error: msg });\r\n}\r\n  }\r\n}\r\n\r\nfunction queueMessage(message: any, sendResponse: Function) {\r\n  // 排队前检测长度并清理过时callback\r\n  messageQueue = messageQueue.filter(\r\n    item => Date.now() - item.ts < MESSAGE_TIMEOUT_MS\r\n  );\r\n  console.log('WebSocket 未连接，消息加入队列', '当前队列长度:', messageQueue.length);\r\n  if (messageQueue.length >= MESSAGE_QUEUE_LIMIT) {\r\n    // 超出队列上限时（异常），逐个fail\r\n    const removed = messageQueue.shift();\r\n    removed?.sendResponse && removed.sendResponse({ success: false, error: '消息队列已满，已丢弃一条旧请求' });\r\n  }\r\n  messageQueue.push({ message, sendResponse, ts: Date.now() });\r\n}\r\n\r\nfunction failAllQueueAndClear(reason = '未知错误') {\r\n  if (messageQueue.length > 0) {\r\n    messageQueue.forEach(item => {\r\n      try {\r\n        item.sendResponse && item.sendResponse({ success: false, error: reason });\r\n      } catch {}\r\n    });\r\n    messageQueue = [];\r\n    console.warn(`[debug] 队列全部清空，因：${reason}`);\r\n  }\r\n}\r\n\r\nfunction broadcastConnectionStatus(connected: boolean) {\r\n  chrome.tabs.query({}, (tabs) => {\r\n    tabs.forEach((tab) => {\r\n      if (tab.id) {\r\n        chrome.tabs.sendMessage(tab.id, {\r\n          type: 'connectionStatus',\r\n          status: connected ? 'connected' : 'disconnected'\r\n        }).catch(() => {});\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nfunction scheduleReconnect() {\r\n  if (reconnectTimer) return;\r\n  reconnectTimer = setTimeout(() => {\r\n    console.log('尝试重新连接...');\r\n    connectWebSocket();\r\n  }, 3000);\r\n}\r\n\r\nfunction sendMessageToVSCode(message: any, sendResponse: Function) {\r\n  if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {\r\n    queueMessage(message, sendResponse);\r\n    debugStatus('sendMessageToVSCode: queue');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    ws.send(JSON.stringify({\r\n      type: 'saveFile',\r\n      content: message.content,\r\n      filename: message.filename,\r\n      savePath: message.savePath || '',  // 传递路径\r\n      timestamp: Date.now()\r\n    }));\r\n    debugStatus('sendMessageToVSCode: sent');\r\n    sendResponse({ success: true });\r\n  } catch (error) {\r\n    const msg = (typeof error === 'object' && error && 'message' in error) ? (error as any).message : String(error);\r\n    sendResponse({ success: false, error: msg });\r\n  }\r\n}\r\n\r\n\r\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\r\n  if (message.action === 'sendToVSCode') {\r\n    debugStatus('收到发送请求');\r\n    sendMessageToVSCode(message, sendResponse);\r\n    return true; // 一定返回true以便异步call\r\n  }\r\n\r\n  if (message.action === 'getConnectionStatus') {\r\n    sendResponse({ connected: isConnected });\r\n    return true;\r\n  }\r\n  if (message.action === 'ping') {\r\n    sendResponse({ connected: isConnected });\r\n    return true;\r\n  }\r\n});\r\n\r\nconnectWebSocket();\r\n\r\nchrome.storage.onChanged.addListener((changes) => {\r\n  if (changes.port) {\r\n    console.log('端口配置已更改，重新连接...');\r\n    // 彻底清理旧队列和ws，从头开始\r\n    failAllQueueAndClear('端口变更清理');\r\n    if (ws) { try { ws.close(); } catch {} }\r\n    setTimeout(() => connectWebSocket(), 500);\r\n  }\r\n});\r\n\r\n// 定时清理已积压超时请求的callback，防止永远pending\r\nsetInterval(() => {\r\n  if (messageQueue.length > 0) {\r\n    const now = Date.now();\r\n    let cleared = 0;\r\n    messageQueue = messageQueue.filter(item => {\r\n      if (now - item.ts > MESSAGE_TIMEOUT_MS) {\r\n        item.sendResponse && item.sendResponse({ success: false, error: '处理超时，后台自动清理' });\r\n        cleared++;\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n    if (cleared > 0) console.warn(`[debug] 定时自动清理超时队列 callback: 清理了${cleared}条`);\r\n  }\r\n}, 10000);\r\n\r\n"],"names":["ws","isConnected","reconnectTimer","messageQueue","debugStatus","prefix","console","log","length","readyState","async","connectWebSocket","onopen","onclose","onerror","onmessage","close","e","wsUrl","chrome","storage","sync","get","port","WebSocket","broadcastConnectionStatus","OPEN","message","sendResponse","shift","send","JSON","stringify","type","content","filename","timestamp","Date","now","success","error","String","processMessageQueue","clearTimeout","scheduleReconnect","failAllQueueAndClear","event","data","reason","forEach","item","warn","connected","tabs","query","tab","id","sendMessage","status","catch","setTimeout","runtime","onMessage","addListener","sender","action","filter","ts","removed","push","queueMessage","savePath","sendMessageToVSCode","onChanged","changes","setInterval","cleared"],"sourceRoot":""}